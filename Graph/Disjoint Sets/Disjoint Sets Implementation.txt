class DSU:
    def __init__(self, graph):
        self.graph = graph
        self.parent = {node: node for node in graph}
        self.rank = {node: 0 for node in graph}
        
    def findParent(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.findParent(self.parent[node])
        return self.parent[node]
    
    def union(self, u, v):
        u = self.findParent(u)
        v = self.findParent(v)
        # Attaching lesser rank to higher rank to reduce the size
        if self.rank[u] > self.rank[v]: 
            self.parent[v] = u
        elif self.rank[u] < self.rank[v]:
            self.parent[u] = v
        else: 
            self.parent[v] = u      # Attaching 'v' to 'u'; path compression
            self.rank[v] += 1
            


class UnionFind:
    def __init__(self, N: int):
        self.parent = list(range(N))
        self.rank = [1] * N

    def find(self, p: int) -> int:
        if p != self.parent[p]:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p: int, q: int) -> bool:
        prt, qrt = self.find(p), self.find(q)
        if prt == qrt: return False 
        if self.rank[prt] > self.rank[qrt]: 
            prt, qrt = qrt, prt 
        self.parent[prt] = qrt 
        self.rank[qrt] += self.rank[prt] 
        return True 